| プログラム | 意図された動作 | バグの場所 | 実行時の挙動 |
|-----------|-------------|-----------|------------|
| **1. NULLアクセス** | 5人の学生データを作成し、80点以上の学生をペアリングして平均点を計算 | `class[4] = NULL`で5番目の要素をNULLに設定しているのに、`process_results`で5つ全て処理しようとする | `students[4]->score`でNULLポインタアクセスが発生し、セグメンテーション違反でクラッシュ |
| **2. 二重free** | リンクリストを作成し、特定の条件でノード間で共有ポインタを設定してからクリーンアップ | `cleanup_list`で`shared`ポインタが複数のノードから参照されている場合、同じメモリを複数回解放してしまう | 20の値を持つノードが`special`となり、60, 75, 80のノードから参照される。これらのノードを解放する際に同じメモリを3回freeして、二重解放エラーが発生 |
| **3. 配列境界エラー** | 0-100の値をヒストグラムに分類して分布を表示 | `while (samples[i] > ranges[index])`で値が100の場合、indexが10になり`histogram[10]`にアクセス（配列サイズは10なので範囲外） | 値100のデータで配列外アクセスが発生。メモリレイアウトによっては不正な値が表示されたり、クラッシュする可能性 |
| **4. ダングリングポインタ** | 文字列バッファを管理し、長さが10を超えるバッファを現在のバッファとして選択して操作 | `init_manager`で`manager->current`を初期化していない。`process_buffers`で条件を満たすバッファがない場合、`current`は未初期化のまま。その後`append_to_current`でアクセス | 10文字以下のバッファしかない場合、`manager->current`が未初期化のままで、`append_to_current`で不正なメモリアクセスが発生。運が悪いとクラッシュ、運が良くても予測不能な動作 |
| **5. SIMDアライメント** | SSE命令を使用して移動平均を計算 | `_mm_load_ps`は16バイトアライメントが必要だが、`data + 1`は4バイトアライメントになっている | アライメント違反により、一般保護例外が発生してクラッシュ |
| **6. 呼び出し規約** | cdeclとstdcallの関数を配列に格納して呼び出し | stdcall関数をcdecl関数ポインタとしてキャストして呼び出している（32bit環境でのみ問題） | スタックのクリーンアップ方法が異なるため、スタックが破壊される。後続の関数呼び出しで異常な動作やクラッシュが発生 |
| **7. バッファオーバーラン** | コロン区切りの入力文字列をパースしてRecord構造体に格納 | 2番目の入力「SPECIALPROMOTION2023」が`tag[8]`に収まらず、`strcpy`でバッファオーバーフロー。また、長い説明文も`description[32]`を超える | スタック上の隣接メモリを破壊。`records`配列の他の要素や、リターンアドレスを破壊する可能性があり、予測不能な動作やクラッシュが発生 |